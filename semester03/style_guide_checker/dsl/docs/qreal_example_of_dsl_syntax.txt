coding: "UTF-8"
shift: { tab: 1 }
wrap: { tab: 2 }
max_line: 120
order: [
	class
	, function
]
forbid: {
	selector: "header definition"
	name: {
		regexp: [
			"_.*"
			, ".*__.*"
		]
	}

}
permit: { selector: "header template" }
name: { pattern: camel }

class
	counter: { max: 1 }

class private varible
	name: { regexp: "m[A-Z].*" }

function bool
	name: { regexp: "(is)|(has).+" }

type
	name: { pattern: capitalize }

macros
	name: { pattern: uppercase }

operator,
	wrap: { pos: new_line }

operator*, operator&
	align: right

header preprocessor pragma
	exist: "once"

preprocessor include
	order: [
		by_level: [
			sys
			, lib
			, custom
		]
	]
	delimiter_between: {
		groups: by_level
		, with: new_line
	}
	path: full

class function definition
	condition: [
		{ body: { regexp: "return m([A-Z].*);" } }
		, { name: { regexp: "\1" } }
	]
	condition: [
		{ body: { regexp: "m[A-Z](.*) = .*" } }
		, { name: { regexp: "set.\1" } }
	]



1. Замечание о каскадировании.
	Значения свойств пересекающихся правил должны по возможности объединяться,
	и лишь при противоречии значений должен осуществляться выбор в пользу значения,
	объявленного в тексте конфига позднее. Например:
		name: { pattern: camel }
		class private varible
			name: { regexp: "m[A-Z].*" }
	Здесь, по правилам CSS, значение name должно быть перегружено для всех имен,
	являющихся приватными полями классов. Но так как в нашем случае значение сложное,
	то их нужно попытаться объединить. То есть, пример выше эквивалентен:
		name: { pattern: camel }
		class private varible
			name: {
				pattern: camel
				, regexp: "m[A-Z].*"
			}
	Проще говоря, каскадирование нужно осуществлять внутри значений: здесь подсвойство
	regexp никак не перекрывает pattern, потому они должны работать оба: имя должно и
	соответствовать регулярному выражению, и быть оформленным в горбатом стиле - как
	легко понять, множество таких имен не пусто.

2. Предложение к усовершенствованию - о паттернах имен.
	Предлагаю ввести несколько значений подсвойства pattern свойства name:
	camel, capitalize, uppercase, lowercase. Технически первые два запрещают использование
	в именах знак подчеркивания, а capitalize еще и обязывает использовать первым символом
	прописную букву (тогда как camel это запрещает). Следущие два запрещают использование
	букв нижнего и верхнего регистров соответственно. Чтобы контролировать соблюдение
	стилей лучше, требуется понимать, что такое "слово" - автоматически подобный AI
	сможет контролировать использование осмысленных английских (и без ошибок написанных)
	слов. По большому счету, в реализации это не так и сложно, поскольку имена можно
	анализировать с использованием словаря, отпимизированного удобным нам образом из
	любого существующего.

3. О путях в include'ах.
	Предлагаю ввести следующие значения свойства path объекта preprocessor include:
	absolute - абсолютный путь до файла, в ""
	relative - относительный путь до файла, в ""
	full - полный путь от каталога, являющимся одним из каталогов поиска заголовочных
		файлов - например, <QtCore/QString> или <boost/fusion/container/list.hpp>
		вместо <QString> или <boost/fusion/include/list.hpp> соответственно. То есть,
		осуществляется запрет на использование путей плоской модели.
	short - напротив, разрешение использования только путей плоской модели.
	Ну и о реализации: черт его знает, как это реализовывать. Не иначе как надо знать
	что-то специальное о библиотеках. Выходит, нет понятий "C++" или "Python". Есть
	понятия "С++/Qt", "C++/boost", "C++/Qt/boost", "Python/BeautifulSoap" etc. Надо
	придумать, что с этим делать. Нужен механизм плагинов/расширений к языку. Или
	не нужен - кто знает?

4. О попытке записать ограничения на имена геттеров и сеттеров.
	Собственно, камень преткновения - а как понять, что метод есть геттер или сеттер?
	Единственное, что пришло в голову - это обратиться селектором к телу метода
	и проверить его на соответствие некоторому простому однострочному регулярному
	выражению, которое, по предположению состовителя стайлгайда, должно в большинстве
	случаев (ясно, что не во всех) верно "угадывать" сеттер или геттер. Предположить
	становится немного проще благодаря тому, что угадывать нужно в окружении не
	неприкосновенного целевого языка, а языка, связанного всеми другими ограничениями
	стайлгайда - например, в гайде QReal нечто, именованное как "m[A-Z].*" в позиции.
	вынужденно соответствующей некоторой переменной или выражению (после return,
	например) с большой долей вероятности окажется приватным полем класса, а однострочный
	метод вида "return m([A-Z].*);" - геттером.
	Тут возникает проблема номер два - надо задать некое опциональное правило, в
	зависимости от того, соблюдается ли наше только что придуманное условие, или нет.
	Такие проблемы возникали и ранее, причем повсеместно - но почти всегда решались
	путем введения в модель языка нового селектора в виду низкой специфичности требований
	условий. Здесь другой случай. Либо надо расширять синтаксис селектора - позволять
	писать что-то в духе:
		class function definition body /return m([A-Z].*);/
			name: { regexp: "\1" }
	либо включать в изначально чисто декларативный язык элементы императивного:
	условия. Пример SQL, впрочем, говорит, что условие в декларативном языке допустимо.
	То есть, я предлагаю сделать корректной конструкцию вроде:
		class function definition
			condition: [
				{ body: { regexp: "return m([A-Z].*);" } }
				, { name: { regexp: "\1" } }
			]
	Значение свойства condition упорядочено, что позволяет договориться: пусть первый
	элемент массива есть условие, а второй - правило, которое следует проверять только
	при истинности условия (ясно, что разумной будет и интерпретация опционального
	третьего элемента как правила ветки else). Такая конструкция вполне укладывается
	в концепцию "сложные вещи должны поддерживаться хотя бы каким-нибудь образом".
	Однако, она открывает некоторые другие вопросы. Например, не очень удобно создавать
	массив conditions, если условных правил много. Если же допускать множественные
	записи такого типа, то нужно пересматривать уже заявленную выше модель каскадирования
	уровня значений - условия не должны перекрывать друг друга. Они должны объединяться.
	Если же некоторый объект языка удовлетворяет сразу многим условиям, то наиболее
	ожидаемым будет следующее поведение: осуществляется попытка применить все правила,
	и только если они противоречивы, внутри каждой пары противоречивых выбирается то,
	что описано ниже по тексту. Есть и тонкость относительно реализации: нужно будет
	крепко подумать, как нумерованные группы регулярных выражений пробрасывать из условия
	condition в его правило. Ну и наконец осталось за кадром то, как добиваться подобного
	поведения, если мы не можешь рассчитывать на распознование поля класса с помощью
	регулярного выражения (читай: исключительно по имени поля)
