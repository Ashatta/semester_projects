coding: "UTF-8"
shift: { tab: 1 }
wrap: { tab: 2 }
max_line: 120
order: [
	class
	, function
]
forbid: {
	selector: "header definition"
	name: {
		regexp: [
			"_.*"
			, ".*__.*"
		]
	}

}
permit: { selector: "header template" }
name: { pattern: camel }

class
	counter: { max: 1 }

class private varible
	name: { regexp: "m[A-Z].*" }

function bool
	name: { regexp: "(is)|(has).+" }

type
	name: { pattern: capitalize }

macros
	name: { pattern: uppercase }

operator,
	wrap: { pos: new_line }

operator*, operator&
	align: right

header preprocessor pragma
	exist: "once"

preprocessor include
	order: [
		by_level: [
			sys
			, lib
			, custom
		]
	]
	delimiter_between: {
		groups: by_level
		, with: new_line
	}
	path: full






1. Замечание о каскадировании.
	Значения свойств пересекающихся правил должны по возможности объединяться,
	и лишь при противоречии значений должен осуществляться выбор в пользу значения,
	объявленного в тексте конфига позднее. Например:
		name: { pattern: camel }
		class private varible
			name: { regexp: "m[A-Z].*" }
	Здесь, по правилам CSS, значение name должно быть перегружено для всех имен,
	являющихся приватными полями классов. Но так как в нашем случае значение сложное,
	то их нужно попытаться объединить. То есть, пример выше эквивалентен:
		name: { pattern: camel }
		class private varible
			name: {
				pattern: camel
				, regexp: "m[A-Z].*"
			}
	Проще говоря, каскадирование нужно осуществлять внутри значений: здесь подсвойство
	regexp никак не перекрывает pattern, потому они должны работать оба: имя должно и
	соответствовать регулярному выражению, и быть оформленным в горбатом стиле - как
	легко понять, множество таких имен не пусто.

2. Предложение к усовершенствованию - о паттернах имен.
	Предлагаю ввести несколько значений подсвойства pattern свойства name:
	camel, capitalize, uppercase, lowercase. Технически первые два запрещают использование
	в именах знак подчеркивания, а capitalize еще и обязывает использовать первым символом
	прописную букву (тогда как camel это запрещает). Следущие два запрещают использование
	букв нижнего и верхнего регистров соответственно. Чтобы контролировать соблюдение
	стилей лучше, требуется понимать, что такое "слово" - автоматически подобный AI
	сможет контролировать использование осмысленных английских (и без ошибок написанных)
	слов. По большому счету, в реализации это не так и сложно, поскольку имена можно
	анализировать с использованием словаря, отпимизированного удобным нам образом из
	любого существующего.

3. О путях в include'ах.
	Предлагаю ввести следующие значения свойства path объекта preprocessor include:
	absolute - абсолютный путь до файла, в ""
	relative - относительный путь до файла, в ""
	full - полный путь от каталога, являющимся одним из каталогов поиска заголовочных
		файлов - например, <QtCore/QString> или <boost/fusion/container/list.hpp>
		вместо <QString> или <boost/fusion/include/list.hpp> соответсвенно. То есть,
		осуществляется запрет на использование путей плоской модели.
	short - напротив, разрешение использования только путей плоской модели.
	Ну и о реализации: черт его знает, как это реализовывать. Не иначе как надо знать
	что-то специальное о библиотеках. Выходит, нет понятий "C++" или "Python". Есть
	понятия "С++/Qt", "C++/boost", "C++/Qt/boost", "Python/BeautifulSoap" etc. Надо
	придумать, что с этим делать. Нужен механизм плагинов/расширений к языку. Или
	не нужен - кто знает?
