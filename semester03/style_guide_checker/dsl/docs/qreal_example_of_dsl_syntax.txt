coding: "UTF-8"
shift: { tab: 1 }
wrap: { tab: 2 }
max_line: 120
order: [
	class
	, function
]
forbid: {
	selector: "header definition"
	name: {
		regexp: [
			"_.*"
			, ".*__.*"
		]
	}

}
permit: { selector: "header template" }
name: { pattern: camel }

class
	counter: { max: 1 }

class private varible
	name: { regexp: "m[A-Z].*" }

function bool
	name: { regexp: "(is)|(has).+" }

type
	name: { pattern: capitalize }

macros
	name: { pattern: uppercase }

operator,
	wrap: { pos: new_line }

operator*, operator&
	align: right

header preprocessor pragma
	exist: "once"

preprocessor include
	order: [
		by_level: [
			sys
			, lib
			, custom
		]
	]
	delimiter_between: {
		groups: by_level
		, with: new_line
	}
	path: full






1. Замечание о каскадировании.
	Значения свойств пересекающихся правил должны по возможности объединяться,
	и лишь при противоречии значений должен осуществляться выбор в пользу значения,
	объявленного в тексте конфига позднее. Например:
		name: { pattern: camel }
		class private varible
			name: { regexp: "m[A-Z].*" }
	Здесь, по правилам CSS, значение name должно быть перегружено для всех имен,
	являющихся приватными полями классов. Но так как в нашем случае значение сложное,
	то их нужно попытаться объединить. То есть, пример выше эквивалентен:
		name: { pattern: camel }
		class private varible
			name: {
				pattern: camel
				, regexp: "m[A-Z].*"
			}
	Проще говоря, каскадирование нужно осуществлять внутри значений: здесь подсвойство
	regexp никак не перекрывает pattern, потому они должны работать оба: имя должно и
	соответствовать регулярному выражению, и быть оформленным в горбатом стиле - как
	легко понять, множество таких имен не пусто.

2. Предложение к усовершенствованию - о паттернах имен.
	Предлагается ввести несколько значений подсвойства pattern свойства name:
	camel, capitalize, uppercase, lowercase. Технически первые два запрещают использование
	в именах знак подчеркивания, а capitalize еще и обязывает использовать первым символом
	прописную букву (тогда как camel это запрещает). Следущие два запрещают использование
	букв нижнего и верхнего регистров соответственно. Чтобы контролировать соблюдение
	стилей лучше, требуется понимать, что такое "слово" - автоматически подобный AI
	сможет контролировать использование осмысленных английских (и без ошибок написанных)
	слов. По большому счету, в реализации это не так и сложно, поскольку имена можно
	анализировать с использованием словаря, отпимизированного удобным нам образом из
	любого существующего.
